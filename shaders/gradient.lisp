;;; A gradient from shader START to END along AXIS.

(in-package :raylisp)

(defclass gradient-shader (shader)
  ((start :initarg :start :accessor start-of)
   (end :initarg :end :accessor end-of)
   (axis :initarg :axis :initform 1 :accessor axis-of)
   (scale :initarg :scale :initform 1.0 :accessor scale-of)
   (smooth :initarg :smooth :initform nil :accessor smoothp)))

(defmethod compute-shader-function ((shader gradient-shader) object scene transform)
  (let ((start (compile-shader (start-of shader) object scene transform))
        (end (compile-shader (end-of shader) object scene transform))
        (axis (axis-of shader))
        (scale (/ 1.0 (scale-of shader))))
    (declare (type (integer 0 2) axis)
             (type function start end)
             (type float scale)
             (optimize speed))
    (if (smoothp shader)
        (sb-int:named-lambda shade-smooth-gradient (obj point normal dot ray counters)
          (declare (optimize speed))
          (declare (type vec point))
          (let* ((start (funcall start obj point normal dot ray counters))
                 (end (funcall end obj point normal dot ray counters))
                 (ratio (imod (* (aref point axis) scale) 2.0)))
            (declare (type vec start end))
            (if (> 1.0 ratio)
                (vec-lerp start end (* ratio 0.5))
                (vec-lerp end start (* ratio 0.5)))))
        (sb-int:named-lambda shade-gradient (obj point normal dot ray counters)
          (declare (optimize speed))
          (declare (type vec point))
          (let* ((start (funcall start obj point normal dot ray counters))
                 (end (funcall end obj point normal dot ray counters))
                 (ratio (imod (* (aref point axis) scale) 1.0)))
            (declare (type vec start end))
            (vec-lerp start end ratio))))))
