<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
  <title>Raylisp Manual</title>
  <link rel="stylesheet" type="text/css" href="raylisp.css"/>
</head>
<body>
  <h1>Raylisp manual</h1>
  <p class="first"><i>Raylisp &#8211; a Common Lisp raytracing engine<br/>by Nikodemus Siivola
      &lt;nikodemus@random-state.net&gt;</i></p>

  <h2 id="toc">Table of Contents</h2>

  <ul>
    <li><a href="#section-introduction">Introduction</a></li>
    <li><a href="#section-protocols">Protocols</a></li>
    <li><a href="#section-dictionary">Dictionary</a></li>
    <li><a href="#section-glossary">Glossary</a></li>
  </ul>

  <h2 id="section-introduction">Introduction</h2>

  <p class="first">Raylisp is an simple Common Lisp raytracer. It is
    neither "complete" nor "good", but the author feels it has some
    interesting design features that might be worth stealing and using
    in more serious raytracers.</p>

  <h3>Shader Based</h3>

  <p class="first">Raylisp is shader based. Each scene object has a
    shader that determines how that object is rendered. Shaders have
    full access to the rest of the scene being rendered, and can be
    optimized based on the features of the scene.</p>

  <p>Note that what Raylisp calls shaders are fairly different from
    eg. Renderman shaders. In Raylisp, a shader simply determines the
    apparent color of an intersection point: shaders are normally purely
    functional, and there is no rendering environment for shaders to mess with
    &mdash; not that anything prevents users from writing shaders that use out-of-band
    communication to talk to each other, or using side-effect.</p>

  <h3>Multiple Scene Representations</h3>
  
  <p class="first">Raylisp uses two different internal representations
    for scenes.</p>

  <p>The <i>scene representation</i> is used to construct a scene
    prior to rendering &#8211; it is CLOS based, designed for
    flexibility, and user-extensible.</o>

  <p>The <i>rendering representation</i> is used during rendering, and
    is designed mainly for efficiency. It is neither extensible nor
    fully documented: redendering objects are opaque types provided
    and used by certain documented functions, but users are ment to
    neither construct nor inspect them directly.</p>

  <p>The first stage of rendering is <i>scene compilation</i>: a
    transformation from the scene representation to the rendering
    representation.</p>

  <h3>Protocol Oriented</h3>

  <p class="first">Scene compilation is controlled by a number of
    documented protocols. Users can implement new behaviours by
    creating new classes and implementing the approriate methods on
    various protocol functions for these.</p>

  <h2 id="section-protocols">Protocols</h3>

  <p class="first">Raylisp protocols can be devided into two categories:
    primary protocols which new subclasses of various protocol classes
    <i>must</i> implement, and secondary protocols which prodivide
    additional behaviours for those classes that implement them.</p>

  <h3>Primary Protocols:</h3>

  <h4 id="protocol-geometry">Geometry protocol</h4>
  
  <p class="first">Geometry protocol controls the transformation of
    geometry from scene representation to rendering representation.</p>
  
  <p>Protocol function:<tt>
      <a class="sym" href="#gf-compute-object-properties">compute-object-properties</a>.
  </tt></p>
  
  <h4 id="protocol-illumination">Illumination Protocol</h4>

  <p class="first">Illumination protocol controls the transformation illumination
    information from the scene representation to rendering representation.</p>

  <p>Protocol function:<tt>
      <a class="sym" href="#gf-compute-light-properties">compute-light-properties</a></tt>.</p>

  <h4 id="protocol-shader">Shader Protocol</h4>

  <p class="first">Shader protocol controls the transformation shading information
    from the scene representation to rendering representation.</p>

  <p>Protocol function:<tt>
      <a class="sym" href="#gf-compute-shader-function">compute-shader-function</a></tt>.</p>

  <h3>Secondary Protocols</h3>

  <h4 id="protocol-bounding">Bounding Protocol</h4>

  <p class="first">Bounding protocol controls the generation of
    secondary data structures used to optimize ray- and
    shadowcasting.</p>

  <p>Protocol function:<tt>
      <a class="sym" href="#gf-compute-object-extents">compute-object-extents</a></tt>.</p>

  <h4 id="protocol-csg">CSG Protocol</h4>

  <p class="first">CSG (Constructive Solid Geometry) protocol controls
    the compilation of composite objects constructed with boolean
    operations for the geometry and bounding protocols.</p>
  
  <blockquote>The CSG protocol is implemented entirely using public
    features of the geometry protocol, and could equally well have
    been a third-party extension to Raylisp; it can be considered an
    example extension.</blockquote>

  <p>Protocl function:<tt>
      <a class="sym" href="#gf-compute-csg-properties">compute-csg-properties</a></tt>.</p>

  <h2 id="section-dictionary">Dictionary</h2>

  <h3>Scene Representation</h3>

  <dl>

    <dt class="def" id="class-scene-light">standard-class <b>SCENE-LIGHT</b></dt>
    <dd>
      <p class="first">Superclass of all lightsources in the scene representation.</p>

      <p>The <a href="#protocol-illumination">illumination protocol</a> must be
	implemented for all subclasses of <tt>scene-light</tt> by an
	approprioate method on <a class="sym"
	href="#gf-compute-light-properties">compute-light-properties</a>.</p>
      <p>Subclasses conventionally have a <tt>-light</tt> postfix.</p>
    </dd>

    <dt class="def" id="class-scene-object">standard-class <b>SCENE-OBJECT</b></dt>
    <dd>
      <p class="first">Superclass of all visible and/or shadowcasting
	objects in the scene representation.</p>
      <p>The <a href="#protocol-geometry">geometry protocol</a> must
	be implemented for all subclasses of <tt>scene-object</tt> by
	an appropriate method on <a class="sym"
	href="#gf-compute-object-properties">compute-object-properties</a>.</p>
      <p>Subclasses for which
	the <a href="#protocol-bounding">bounding protocol</a> is
	implemented by an appropriate method on <a class="sym"
	href="#gf-compute-object-extents">compute-object-extents</a> gain benefit
	optimizations based on spatial hiearchies in ray- and
	shadowcasting.</p>
      <p>Subclasses for which the <a href="#protocol-csg">CSG
	protocol</a> is implemented by an appropriate method
	on <a class="sym"
	href="#gf-compute-csg-properties">compute-csg-properties</a>
	can participate in CSG operations.</p>
      <p>Subclasses have no special naming conventions.</p>
    </dd>
    
    <dt class="def" id="class-shader">standard-class <b>SHADER</b></dt>
    <dd>
      <p class="first">Superclass of all shaders.</p>
      <p>The <a href="#protocol-shader">shader protocol</a> must be
	implemented for all subclasses of <tt>shader</tt> by an
	approriate method on <a class="sym"
	href="#gf-compute-shader-function">compute-shader-function</a>.</p>
      <p>Subclasses 
	conventionally have a <tt>-shader</tt> postfix.</p>
    </dd>
  </dl>

  <h3>Protocol Functions</h3>

  <dl>

    <dt class="def" id="compute-csg-properties">generic-function <b>COMPUTE-CSG-PROPERTIES</b> <i>object scene</i>
    &rArr; plist</dt>
    <dd>
      <p class="first">Called for each <a class="sym"
	href="#class-scene-object">scene-object</a> participating in a
	CSG operation. Methods <i>must</i> return a property list
	describing the object as a solid:</p>
      <p><b>:all-intersections</b> is a function called with two
	vectors: an origin and a direction, and returns
	a <tt>simple-vector</tt> of <tt>csg-intersection</tt>
	structures, with one instance for each intersection distance
	greater then <a class="sym" href="#epsilon">epsilon</a>,
	sorted in order from closest to most distant from the given
	origin. The <tt>object</tt> slot of each structure must be
	filled either with the result of calling <a class="sym"
	href="#fun-compile-scene-object">compile-scene-object</a> with
	the object argument of the call
	to <tt>compute-csg-properties</tt> or a surrogate object to be
	used in further calculations for that intersection.</p>
      <p><b>:inside</b> is a function is called with a position vector, and
	returns true if the designated location is inside the object.</p>
    </dd>

    <dt class="def" id="gf-compute-light-properties">generic-function <b>COMPUTE-LIGHT-PROPERTIES</b> <i>light scene</i>
    &rArr; plist</dt>
    <dd>
      <p class="first">Called for each <a class="sym"
	href="#class-scene-light">scene-light</a> during scene
	compilation. Methods <i>must</i> return  a property list describing the light, in which:</p>

      <p><b>:incident-light</b> is a function called with
	a <i>hit location vector</i>. It must return an incident light vector,
	which points from the hit location to the location of the
	light, or <tt>NIL</tt> if the light is never visible from the
	given location. The light vector may be unnormalized, and its
	length can be used to communicate eg. the distance of the
	light from the location to the corresponding illumination
	function.
      </p>

      <p><b>:illumination</b> is a function called with the
	same <i>hit location vector</i> that the indicedent light
	function was called with earlier, the <i>incident light
	vector</i> returned by that call, and a <i>counter object.</i>
	It must return the color of incident light at the location as
	primary value, and the length of the incident light vector as
	the secondary value.
      </p>
    </dd>
    
    <dt class="def" id="gf-compute-object-extents">generic-function <b>COMPUTE-OBJECT-EXTENTS</b> <i>object</i>
    &rArr; min, max</dt>
    <dd>
      <p class="first">Called for each active <a class="sym"
	href="#class-scene-object">scene-object</a> during scene
	compilation. Methods <i>must</i> return either position vectors for the extreme
	corners of an axis-aligned bounding box that contains the object, or <tt>NIL</tt>
	to indicate unbounded object geometry. The default method returns <tt>NIL</tt>.</p>
    </dd>

    <dt class="def" id="gf-compute-object-properties">generic-function <b>COMPUTE-OBJECT-PROPERTIES</b> <i>object scene</i>
    &rArr; plist</dt>
    <dd>
      <p class="first">Called for each a <a class="sym"
	href="#class-scene-object">scene-object</a> during scene
	compilation. Methods <i>must</i> return a property list
	describing the geometry of the object, in which:</p>
      <p><b>:intersection</b> is a function called with
	a <a class="sym" href="#class-ray">ray</a>. It <i>must</i>
	return true if the ray intersects the object and the distance
	from <a class="sym" href="#fun-ray-origin">ray-origin</a> to
	the intersection point is between <a class="sym"
	href="#const-epsilon">epsilon</a> and <a class="sym"
	href="#fun-ray-extent">ray-extent</a>. If the function returns
	true it <i>must</i> also set the <a class="sym"
	href="#fun-ray-extent">ray-extent</a> to the intersection
	distance. The intersection function may also return as
	secondary value a surrogate object to be used instead of the
	original one in shading and normal calculations. If a
	surrogate is returned, it <i>must</i> be a value returned by a
	call to <a class="sym"
	href="#fun-compile-scene-object">compile-scene-object</a>;
	different calls to the same intersection function may return
	different surrogate objects or reuse the same one.
      </p>
      <p><b>:normal</b> is a function called with a position vector
	indicating a position on the surface of the object.
	<i>Must</i> return the surface normal of the object at that
	point. Surface normals returned by the normal
	function <i>must</i> point to the outside of the object.
      </p>
    </dd>

    <dt class="def" id="gf-compute-shader-function">generic-function <b>COMPUTE-SHADER-FUNCTION</b> <i>shader scene</i>
    &rArr; function</dt>
    <dd>
      <p class="first">Called with a <a class="sym" href="#class-shader">shader</a> and the scene. <i>Must</i>
	return the corresponding shader function.</p>
      <p>The shader function is called with an hit location vector, surface normal,
	the dot-product between the surface normal and ray direction, ray, and a counter object.
	It <i>must</i> return the apparent color of the hit location for the ray.</p>
    </dd>

  </dl>

  <h3>Scene Compilation</h3>

  <dl>
    
    <dt class="def" id="fun-compile-scene-light">function <b>COMPILE-SCENE-LIGHT</b> <i>light scene</i></dt>
    <dd>
      <p class="first">Returns on an opaque rendering object
	representing the <a class="sym"
	href="#class-scene-light">scene-light</a> in the scene, or
	NIL if the light is inactive and should be elided. Implemented by
	<a class="sym"
	href="#gf-compute-light-properties">compute-light-properties</a>.
      </p>
    </dd>

    <dt class="def" id="fun-compile-scene-object">function <b>COMPILE-SCENE-OBJECT</b> <i>object scene</i></dt>
    <dd>
      <p class="first">Returns on an opaque rendering object
	representing the <a class="sym"
	href="#class-scene-object">scene-object</a> in the scene, or
	NIL if the object is inactive and should be elided. Implemented by
	<a class="sym"
	href="#gf-compute-object-properties">compute-object-properties</a>
	and <a class="sym"
	href="#gf-compute-object-extents">compute-object-extents</a>.
      </p>
    </dd>

    
  </dl>

  <hr color="red"/>


  <h2 id="section-glossary">Glossary</h2>

  <dl>
    <dt class="glos" id="glos-hit-location">hit location</dt>
    <dd>Vector specifying a point in space where a ray and an object intersect.</dd>
    

    <dt class="glos" id="glos-illumination-function">illumination function</dt>
    <dd>A function called with
      a <a href="#glos-hit-location">hit location</a> vector,
      and a <a href="#glos-light-vector">light vector</a> returned by
      an earlier call to the
      corresponding <a href="#glos-incident-light">incident light</a>
      function. Returns the color of incident light at point, the
      length of the light vector as a secondary value. An illumination
      function is responsible for shadowcasting for the lightsource it
      represents. See: <a class="sym"
      href="#fun-shadow-function">shadow-function</a>.</dd>

    <dt class="glos" id="glos-light-vector">light vector</dt>
    <dd>Vector pointing from a <a href="#glos-hit-location">hit location</a> to a lightsource.
      Light vectors may be unnormalized: <a href="#glos-incident-light-function">incident light functions</a>
      can use the length to communicate with the corresponding
      <a href="#glos-illumination-function">illumination functions</a>.</dd>

      
    <dt class="glos" id="glos-intersection-function">intersection function</dt>
    <dd><p class="first">Function called with a <a class="sym"
      href="#class-ray">ray</a> to determine if the ray intersects the
      object whose geometry is described by the intersection function.</p>

      <p>A ray is considered to intersect an object if the distance
	between the <a class="sym"
	href="#fun-ray-origin">ray-origin</a> and <a class="sym"
	href="#glos-hit-location">hit location</a> is
	between <a class="sym" href="#const-epsilon">epsilon</a>
	and <a class="sym" href="#fun-ray-extent">ray-extent</a>.
	If so, the function sets the
	<a class="sym" href="#fun-ray-extent">ray-extent</a> to
	this distance and returns <tt>t</tt>. Otherwise it
	returns <tt>nil</tt>.</p>

      <p>The intersection function also may also return (as secondary
	value) a <a href="#glos-surrogate-object">surrogate object</a>.</dd>

      <dt class="glos" id="glos-surrogate-object">surrogate object</dt>
      <dd>An object used instead of the original object for shading and
	normal calculations, po
constructed by <a class="sym"
	href="#compile-object">compile-object</a>
(although it is possible to
	call <tt>compile-object</tt> every time intersection function
	is called, it is highly preferable to call it only once, at
	the time when <tt>object-functions</tt> is called).

       (although it is possible to
	call <tt>compile-object</tt> every time intersection function
	is called, it is highly preferable to call it only once, at
	the time when <tt>object-functions</tt> is called).</dd>

    <dt class="glos" id="glos-normal-function">normal function</dt>
    <dd>Function is called with a position vector, and
	must return the surface normal of the object at that point.</dd>

  </dl>


  <hr/>
  <hr/>
  <hr/>

  <h3>Types</h3>

  <dl>
    <dt id="float.type">
      type <tt>FLOAT</tt> [min [max]] </dt>
    <dd>
      <p class="first">Shadows <tt>cl:float</tt>. Equivalent to the
	floating point type specified
	by <tt>*read-default-float-format*</tt> at the time Raylisp
	was compiled. Unless otherwise specified, all floating point
	values referred to either by Raylisp or this manual are of
	this type.</p>
    </dd>

    <dt id="simple-vector.type">
      type <tt>SIMPLE-VECTOR</tt> [size]</dt>
    <dd>
      <p class="first">Shadows <tt>cl:simple-vector</tt>, but is
	equivalent to it as a type specifier.</p>
      <p>See also:
	type <a href="#vector.type">vector</a>, and
	functions <a href="#vector.fun">vector</a>
	and <a href="#simple-vector.fun">simple-vector</a>.</p></dd>

    <dt id="vector.type">
      type <tt>VECTOR</tt></dt>
    <dd>
      <p class="first">Shadows <tt>cl:vector</tt>. Equivalent to the
	type specifier <tt>(cl:simple-array raylisp:float (3))</tt>.
	Denotes a mathematical 3-dimensional vector. Unless otherwise
	specified, all vectors referred to by Raylisp or this manual
	are of this type.</p>
      <p>See also:
	type <a href="#simple-vector.type">simple-vector</a>, and
	functions <a href="#vector.fun">vector</a>
	and <a href="#simple-vector.fun">simple-vector</a>.</p></dd>
  </dl>

  <h3>Constants</h3>

  <dl>
    <dt id="epsilon.const">
      constant <tt>EPSILON</tt></dt>
    <dd>
      <p class="first">A small value of type <a href="#float.type"
        class="sym">float</a>, used as a liminal value in rendering:
	distances upto <tt>epsilon</tt> are typically considered zero.</p>

      <p>See
	also: <a href="#float-epsilon.const">float-epsilon</a>.</p></dd>

    <dt id="float-epsilon.const">
      constant <tt>FLOAT-EPSILON</tt></dt>
    <dd>
      <p class="first">Floating point epsilon of
	type <a href="#float.type" class="sym">float</a>.</p>

      <p>See also: <a class="sym"
	href="epsilon.const">epsilon</a>.</p></dd>

    <dt id="float-negative-infinity.const">
      constant <tt>FLOAT-NEGATIVE-INFINITY</tt></dt>
    <dd>
      <p class="first">Negative inifinity of
      type <a href="#float.type" class="sym">float</a>.</p></dd>

    <dt id="float-positive-infinity.const">
      constant <tt>FLOAT-POSITIVE-INFINITY</tt></dt>
    <dd>
      <p class="first">Positive inifinity of
      type <a href="#float.type" class="sym">float</a>.</p></dd>

    <dt id="least-positive-float.const">
      constant <tt>LEAST-POSITIVE-FLOAT</tt></dt>
    <dd>
      <p class="first">Smallest positive (possibly denormalized) value
	of type <a href="#float.type" class="sym">float</a> that is
	not zero.</p></dd>

    <dt id="least-positive-normalized-float.const">
      constant <tt>LEAST-POSITIVE-NORMALIZED-FLOAT</tt></dt>
    <dd>
      <p class="first">Smallest positive normalized value of
	type <a href="#float.type" class="sym">float</a> that is
	not zero.</p></dd>
    
    <dt id="least-neagtive-float.const">
      constant <tt>LEAST-NEGATIVE-FLOAT</tt></dt>
    <dd>
      <p class="first">Smallest negative (possibly denormalized) value
	of type <a href="#float.type" class="sym">float</a> that is
	not zero.</p></dd>

    <dt id="least-neagtive-normalized-float.const">
      constant <tt>LEAST-POSITIVE-NORMALIZED-FLOAT</tt></dt>
    <dd>
      <p class="first">Smallest neagtive normalized value of
	type <a href="#float.type" class="sym">float</a> that is
	not zero.</p></dd>
    
    <dt id="most-negative-float.const">
      constant <tt>MOST-NEGATIVE-FLOAT</tt></dt>
    <dd>
      <p class="first">Largest positive value of type <a href="#float.type"
	class="sym">float</a> that is not infinite.</p></dd>
      
    <dt id="most-positive-float.const">
      constant <tt>MOST-POSITIVE-FLOAT</tt></dt>
    <dd>
      <p class="first">Largest positive value of type <a href="#float.type"
	class="sym">float</a> that is not infinite.</p></dd>
  </dl>

  <h3>Operators</h3>

  <dl>
    <dt id="float.fun">
      function <tt>FLOAT real &rArr; float</tt></dt>
    <dd>
      <p class="first">Called with a real number, returns
	a <a class="sym" href="#float.type">float</a> numerically
	equal to it.</p>
    </dd>

    <dt id="floatp.fun">
      function <tt>FLOATP object &rArr; boolean</tt></dt>
    <dd>
      <p class="first">Called with any object, returns <tt>t</tt> if
	the object is a <a class="sym" href="#float.type">float</a>,
	and <tt>nil</tt> otherwise.</p>
    </dd>

    <dt id="least-positive-quadratic-root.fun">
      function <tt>LEAST-POSITIVE-QUADRATIC-ROOT a b c &rArr; float</tt></dt>
    <dd>
      <p class="first">Returns the smallest positive real root
	of <tt>ax<sup>2</sup>+bx+c</tt>, or -1.0 if there are no
	positive real roots. Arguments <i>a</i>, <i>b</i>,
	and <i>c</i> must be of type <a href="#float.type"
	class="sym">float</a>.</p></dd>

    <dt id="map-positive-quadratic-roots.fun">
      function <tt>MAP-POSITIVE-QUADRATIC-ROOTS function a b c &rArr;
	list</tt></dt>
    <dd>
      <p class="first">Returns a <tt>list</tt> containing the results
	  of calling <i>function</i> with positive real roots
	  of <tt>ax<sup>2</sup>+bx+c</tt>, from the smallest to the
	  largest. Arguments <i>a</i>, <i>b</i>, and <i>c</i> must be
	  of type <a href="#float.type"
	  class="sym">float</a>.</p></dd>

    <dt id="simple-vector.fun">
      function <tt>SIMPLE-VECTOR &rest elements &rArr; simple-vector</tt></dt>
    <dd>
      <p class="first">Shadows <tt>cl:simple-vector</tt>, and is
	equivalent to the function <tt>cl:vector</tt>.</p>
      <p>See also:
	function <a class="sym" href="#vector.fun">vector</a>, and
	types <a class="sym"
	href="#simple-vector.type">simple-vector</a>
	and <a class="sym" href="#vector.type">vector</a>.</p></dd>
  </dl>  

  <h3>Vector Operations</h3>

  <dl>
    <dt id="cros-product.fun">
      

    <dt id="dot-product.fun">
      function <tt>DOT-PRODUCT a b &rArr; float</tt></dt>
    <dd>
      <p class="first">Returns the scalar product
	of <a href="#vector.type" class="sym">vectors</a> <i>a</i>
	and <i>b</i>.</p>
      <pre>a&sdot;b = a<sub>x</sub>b<sub>x</sub> + a<sub>y</sub>b<sub>y</sub> + a<sub>z</sub>b<sub>z</sub></pre>
      <p>See also: <a href="dot-product*.fun"
		      class="sym">dot-product*</a>.</p></dd>

    <dt id="dot-product*.fun">
      function <tt>DOT-PRODUCT* ax ay az bx by bz &rArr; float</tt></dt>
    <dd>
      <p class="first">Returns the scalar product of vector <tt>a</tt>
	denoted by <i>ax</i>, <i>ay</i>, and <i>az</i>, and
	vector <tt>b</tt> denoted by <i>bx</i>, <i>by</i>,
	and <i>bz</i>.</p>
      <pre>a&sdot;b = a<sub>x</sub>b<sub>x</sub> + a<sub>y</sub>b<sub>y</sub> + a<sub>z</sub>b<sub>z</sub></pre>
      <p>See also: <a href="dot-product.fun"
		      class="sym">dot-product</a>.</p></dd>
    
    <dt id="hadamard-product.fun">
      function <tt>HADAMARD-PRODUCT a b &rArr; vector</tt></dt>
    <dd>
      <p class="first">Returns the hadamard product
	of <a href="#vector.type" class="sym">vectors</a> <i>a</i>
	and <i>b</i>.</p>
      <pre>hadamard(a,b) = a<sub>x</sub>b<sub>x</sub>i + a<sub>y</sub>b<sub>y</sub>j + a<sub>z</sub>b<sub>z</sub>k</pre>
    </dd>

    <dt id="vector.fun">
      function <tt>VECTOR x y z &rArr; vector</tt></dt>
    <dd>
      <p class="first">Shadows <tt>cl:vector</tt>. Constructs and
	returns a <a href="#vector.type" class="sym">vector</a>
	with <a class="sym"
	href="#float.type">floats</a> <i>x</i>, <i>y</i>, and <i>z</i>
	as initial elements.</p>
      <pre>v = xi + yj + zk</pre>
      <p>See also:
	function <a class="sym"
	href="#simpl-vector.fun">simple-vector</a>, and
	types <a class="sym"
	href="#simple-vector.type">simple-vector</a>
	and <a class="sym" href="#vector.type">vector</a>.</p></dd>
    
    <dt id="vector-add.fun">
      function <tt>VECTOR-ADD a b &rArr; vector</tt></dt>
    <dd>
      <p class="first">Returns the result of ddition
	of <a href="#vector.type" class="sym">vectors</a> <i>a</i>
	and <i>b</i>.</p>
      <pre>a+b = (a<sub>x</sub>+b<sub>x</sub>)i + (a<sub>y</sub>+b<sub>y</sub>)j + (a<sub>z</sub>+b<sub>z</sub>)k</pre>
    </dd>

    <dt id="vector-add-fraction">
      function <tt>VECTOR-ADD-FRACTION a b f &rArr; vector</tt></dt>
    <dd>
      <p class="first">Return the result of adding
	to <a href="#vector.type" class="sym">vector</a> <i>a</i>
	the <a href="#vector.type" class="sym">vector</a> <i>b</i>
	multiplied by the <a href="#float.type" class="sym">float</a>
	<i>f</i>.</p>
      <pre>a+bf = (a<sub>x</sub>+b<sub>x</sub>f)i + (a<sub>y</sub>+b<sub>y</sub>f)j + (a<sub>z</sub>+b<sub>z</sub>f)k</pre></dt>

    <dt id="vector-div.fun">
      function <tt>VECTOR-DIV v f &rArr; vector</tt></dt>
    <dd>
      <p class="first">Returns the result of
	dividing <a href="#vector.type"
	class="sym">vector</a> <i>v</i> by <a href="#float.type"
	class="sym">float</a> <i>f</i>.</p>
      <pre>v/f = (v<sub>x</sub>/f)i + (v<sub>y</sub>/f)j + (v<sub>z</sub>/f)k</pre>
    </dd>

    <dt id="vector-inverse.fun">
      function <tt>VECTOR-INVERSE v &rArr; vector</tt></dt>
    <dd>
      <p class="first">Returns the inverse of <a href="#vector.type"
	class="sym">vector</a> <i>v</i> with respect to
	addition.</p>
      <pre>-v = -v<sub>x</sub>i - v<sub>y</sub>j - v<sub>z</sub>k</pre></dd>

    <dt id="vector-lerp.fun">
      function <tt>VECTOR-LERP a b f &rArr; vector</tt></dt>
    <dd>
      <p class="first">Returns the result of linear interpolation
	between <a href="#vector.type"
	class="sym">vectors</a> <i>a</i> and <i>b</i> using the
	interpolation coefficient <i>f</i>.</p>
      <pre>lerp(a,b,f) = (1-f)a + fb</pre>

    <dt id="vector-length.fun">
      function <tt>VECTOR-LENGTH v &rArr; float</tt></dt>
    <dd>
      <p class="first">Returns the length of
      the <a href="#vector.type"
      class="sym">vector</a> <i>v</i>.</p>
      <pre>|v| = &radic;(v<sub>x</sub><sup>2</sup> + v<sub>y</sub><sup>2</sup> + v<sub>z</sub><sup>2</sup>)</pre>

    <dt id="vector-mul.fun">
      function <tt>VECTOR-MUL v f &rArr; vector</tt></dt>
    <dd>
      <p class="first">Returns the result of
	multiplying <a href="#vector.type"
	class="sym">vector</a> <i>v</i> by <a href="#float.type"
	class="sym">float</a> <i>f</i>.</p>
      <pre>fv = fv<sub>x</sub>i + fv<sub>y</sub>j + fv<sub>z</sub>k</pre>
    </dd>

    <dt id="vector-sub.fun">
      function <tt>VECTOR-SUB a b &rArr; vector</tt></dt>
    <dd>
      <p class="first">Returns the result of substraction
	of <a href="#vector.type" class="sym">vectors</a> <i>a</i>
	and <i>b</i>.</p>
      <pre>a-b = (a<sub>x</sub>-b<sub>x</sub>)i + (a<sub>y</sub>-b<sub>y</sub>)j + (a<sub>z</sub>-b<sub>z</sub>)k</pre>
    </dd>
  </dl>

  <h3>Tools</h3>

  <dl>
    <dt id="shadow-function">
      function <tt>SHADOW-FUNCTION</tt> vector scene</dt>
    <dd>
      <p class="first">Called with a position vector for a lightsource
	and the current scene. Returns a shadowcasting function for
	the location.</p>
      <p>The shadowcasting function is called with an intersection point,
	normalized light vector, and the distance of the lightsource from
	the intersection. It returns a solid object casting a shadow from
	the lightsource to the point, or NIL if no shadow is cast.</p>
      <p><b>FIXME</b>: Implementing translucent shadows will require
	this to change.</p>
    </dd>
  </dl>

</body>
</html>
